# Redis缓存技术开发 #

:arrow_down:[Redis缓存简介](#a1)

:arrow_down:[Redis缓存使用](#a2)

<p id="a1"></p>

### Redis缓存简介 ###

redis大多时候都是作为缓存来整合到项目中的。为什么要使用缓存呢？我们在大多数访问web网站无非是查询一些数据，比如逛淘宝买东西，学校选课的时候。这个时候你会发觉逛淘宝不会怎么卡，但是相对于学校选课来说，你能很明显的感觉的加载缓慢，甚至服务崩溃（当然也有些做的好的学校:sweat_smile:） 。这是由于服务端开发设计模式不同所导致的，像淘宝这样的大型公司做的服务端，用了多个服务器实现了**负载均衡，数据库读写分离，微服务，缓存等多种技术**才到达了千万级的并发服务。

然而对于学校相信大多数学校但是单机服务，也就是服务部署，数据库部署都是在同一台机器上，而且服务器数量也只有一台或者几台工作。像这样的不做其他优化最大也就支持几百的并发量，但是选课的时候并发量估计是不止几百的，进而导致服务器超负荷工作最终导致服务崩溃。

当然学校不可能像大公司那样拥有那么全面的技术以及成千上万的服务器来支持并发服务，但是可以使用缓存技术来提高并发量，我们这里就来简单来介绍缓存技术。

首先我们都知道缓存是存在内存中的，所以它的读写速度是非常快的，这里就可以和数据库读写做对比，数据库的内容是持久化到文件中了的，也就是外存，显然这种读写速度是比不上内存的，所以使用缓存可以让更多的访问落在读取内存上，这种读取比访问数据库是快很多的。而且每读取一次数据库，就得建立一次数据库连接，执行命令，返回结果，断开数据连接。这个过程是非常消耗资源的，如果访问的人过多，就会建立多个连接，如果不释放这些连接，最后会导致访问资源耗尽。看一下下面几个例子：

一个普通的数据库访问API所耗时：

![as](https://github.com/Lumnca/Redis/blob/master/img/a2.png)

这是一个从数据库中查询一本书的数据接口， 可以看到响应速度只有几ms，这取决于数据库的数据数量和接口实现的业务逻辑。我这里的数据只有1800条所以看不到太大的延迟，但是我们稍微提升了一下并发量在100左右

![](https://github.com/Lumnca/Redis/blob/master/img/a3.png)

可见大多数访问延时都有几百ms，比单个访问也高了一百倍左右。如果继续提升并发量，更能看出这个响应延迟。

接下来我们看下缓存的访问时延，在已经有了缓存数据的情况下：

![](https://github.com/Lumnca/Redis/blob/master/img/a4.png)

可以看到普遍都是几ms的延迟这是由于这个接口的数据所要返回的数据已被写入缓存，我们来看下这个接口的缓存逻辑：

```java
  @Cacheable(value = "c1")
    public String getBookById(Integer id){
        System.out.println("==================GetBookByID("+id+")==================");
        return JSON.toJSONString(bookDao.getOne(id));
    }
```

这是spring boot所集成的redis功能，其中@Cacheable(value = "c1")是使用缓存，只要这个方法第一次被访问就会被写入缓存，由于缓存是key-value型的，这里就会把方法参数作为key值，其方法返回值的内容作为value值。并设置了缓存过期的时间，在这段时间内，如果访问这个方法的参数在缓存中存在，那么这个步骤将不会被再次执行，其中的打印语句System.out.println也不会再次执行。

所以像这样所有被访问的接口参数都会被写入缓存，下一次再次访问就从内存中读取，而不走数据库，因此提高了访问速度。

****

<p id="a2"></p>

### Redis缓存使用 ###

我这里的缓存都是使用spring boot来开发整合，具体配置步骤参见这篇文章[spring boot整合Redis](https://github.com/Lumnca/Spring-Boot/blob/master/Spring%20Boot%E6%95%B4%E5%90%88NoSql.md)

关于代码上面这里面都有介绍。




