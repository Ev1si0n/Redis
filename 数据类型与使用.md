# :o2:Redis 数据类型与使用

<b id="t"></b>

### :arrow_down:[数据类型](#a1)

### :arrow_down:[键Key](#a2)

### :arrow_down:[字符串](#a3)

<p id="a1"></p>

### :crystal_ball:数据类型

:arrow_double_up:[返回目录](#t)

Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。

**String（字符串）**

string 是 redis 最基本的类型，你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。

string 类型是二进制安全的。意思是 redis 的 string 可以包含任何数据。比如jpg图片或者序列化的对象。

string 类型是 Redis 最基本的数据类型，string 类型的值最大能存储 512MB。

可以向如下使用：

```
redis 127.0.0.1:6379> SET name "lumnca"
OK
redis 127.0.0.1:6379> GET name
"lumnca"
```

可以看见和以前一样，使用GET与SET进行访问修改。使用DEL可以删除数据

```
del name
(integer) 1
```

出现(integer) 1说明删除成功。

**Hash（哈希）**

Redis hash 是一个键值(key=>value)对集合。

Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。

如下：

```shell
127.0.0.1:6379> HMSET student name "lumnca" age "21" sex "man"
OK
127.0.0.1:6379> HGET student name
"lumnca"
127.0.0.1:6379> HGET student age
"21"
127.0.0.1:6379> HGET student sex
"man"
127.0.0.1:6379> 
```

实例中我们使用了 Redis HMSET, HGET 命令，HMSET 设置了两个 field=>value 对, HGET 获取对应 field 对应的 value。每个 hash 可以存储 232 -1 键值对（40多亿）

**List（列表）**
Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。

```
127.0.0.1:6379> lpush lists "lumnca"
(integer) 1
127.0.0.1:6379> lpush lists "key"
(integer) 2
127.0.0.1:6379> lpush lists "marry"
(integer) 3
127.0.0.1:6379> lrange lists 0 2
1) "marry"
2) "key"
3) "lumnca"
127.0.0.1:6379> 
```

**Set（集合）**

Redis的Set是string类型的无序集合。

集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。

sadd 命令:添加一个 string 元素到 key 对应的 set 集合中，成功返回1，如果元素已经在集合中返回 0，如果 key 对应的 set 不存在则返回错误。

`sadd key member`
实例
```
redis 127.0.0.1:6379> DEL runoob
redis 127.0.0.1:6379> sadd runoob redis
(integer) 1
redis 127.0.0.1:6379> sadd runoob mongodb
(integer) 1
redis 127.0.0.1:6379> sadd runoob rabitmq
(integer) 1
redis 127.0.0.1:6379> sadd runoob rabitmq
(integer) 0
redis 127.0.0.1:6379> smembers runoob

1) "redis"
2) "rabitmq"
3) "mongodb"
```
注意：以上实例中 rabitmq 添加了两次，但根据集合内元素的唯一性，第二次插入的元素将被忽略。

集合中最大的成员数为 232 - 1(4294967295, 每个集合可存储40多亿个成员)。

**zset(sorted set：有序集合)**

Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。
不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。

zset的成员是唯一的,但分数(score)却可以重复。

zadd 命令:添加元素到集合，元素在集合中存在则更新对应score

z`add key score member `

```
redis 127.0.0.1:6379> DEL runoob
redis 127.0.0.1:6379> zadd runoob 0 redis
(integer) 1
redis 127.0.0.1:6379> zadd runoob 0 mongodb
(integer) 1
redis 127.0.0.1:6379> zadd runoob 0 rabitmq
(integer) 1
redis 127.0.0.1:6379> zadd runoob 0 rabitmq
(integer) 0
redis 127.0.0.1:6379> > ZRANGEBYSCORE runoob 0 1000
1) "mongodb"
2) "rabitmq"
3) "redis"
```

<p id="a2"></p>

### :crystal_ball:键Key

:arrow_double_up:[返回目录](#t)

上面的例子中使用了键的添加删除方法，其格式为：

```
COMMAND KEY_NAME
```

其中命令含有如下：

|序号|命令|说明|
|:--|:-----:|:---:|
|1|	DEL key|该命令用于在 key 存在时删除 key。|
|2|	DUMP key |序列化给定 key ，并返回被序列化的值。|
|3	|EXISTS key |检查给定 key 是否存在。|
|4	|EXPIRE key seconds|为给定 key 设置过期时间，以秒计。|
|5	|EXPIREAT key timestamp |EXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置过期时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)。|
|6	|PEXPIRE key milliseconds |设置 key 的过期时间以毫秒计。|
|7	|PEXPIREAT key milliseconds-timestamp |设置 key 过期时间的时间戳(unix timestamp) 以毫秒计|
|8	|KEYS pattern |查找所有符合给定模式( pattern)的 key 。|
|9	|MOVE key db |将当前数据库的 key 移动到给定的数据库 db 当中。|
|10	|PERSIST key |移除 key 的过期时间，key 将持久保持。|
|11	|PTTL key |以毫秒为单位返回 key 的剩余的过期时间。|
|12	|TTL key |以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)。|
|13	|RANDOMKEY |从当前数据库中随机返回一个 key 。|
|14	|RENAME key newkey |修改 key 的名称|
|15	|RENAMENX key newkey |仅当 newkey 不存在时，将 key 改名为 newkey 。|
|16	|TYPE key |返回 key 所储存的值的类型。|

如下使用：

```
127.0.0.1:6379> SET name 'lumnca'
OK
127.0.0.1:6379> DUMP name
"\x00\x06lumnca\b\x00\xfe\x97p0s\xaf\n/"
127.0.0.1:6379> EXISTS name
(integer) 1
127.0.0.1:6379> EXPIRE name 500
(integer) 1
127.0.0.1:6379> TTL name
(integer) 479
127.0.0.1:6379> RENAME name newname
OK
127.0.0.1:6379> TYPE newname
string
127.0.0.1:6379> PERSIST newname
(integer) 1
127.0.0.1:6379> TTL newname
(integer) -1
127.0.0.1:6379> 
```

<p id="a3"></p>

### :crystal_ball:字符串

:arrow_double_up:[返回目录](#t)

前面也介绍过字符串的基本用法直接在键值后加值即可，如下是其他使用命令：

|序号|	命令|描述|
|:--:|:--:|:--:|
|1	|SET key value |设置指定 key 的值|
|2	|GET key |获取指定 key 的值。|
|3|	GETRANGE key start end| 返回 key 中字符串值的子字符|
|4|	GETSET key value | 将给定 key 的值设为 value ，并返回 key 的旧值(old value)。|
|5	|GETBIT key offset | 对 key 所储存的字符串值，获取指定偏移量上的位(bit)。|
|6	|MGET key1 [key2..] |获取所有(一个或多个)给定 key 的值。|
|7	|SETBIT key offset value |对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。|
|8|	SETEX key seconds value|将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位)。|
|9|	SETNX key value |只有在 key 不存在时设置 key 的值。|
|10|SETRANGE key offset value| 用value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始。|
|11	|STRLEN key|返回 key 所储存的字符串值的长度。|
|12	|MSET key value [key value ...]|同时设置一个或多个 key-value 对。|
|13|	MSETNX key value [key value ...] |同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。|
|14|PSETEX key milliseconds value |这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，而不是像 SETEX 命令那样，以秒为单位。|
|15	|INCR key|将 key 中储存的数字值增一。|
|16|	INCRBY key increment|将 key 所储存的值加上给定的增量值（increment） 。|
|17|	INCRBYFLOAT key increment|将 key 所储存的值加上给定的浮点增量值（increment） 。|
|18|	DECR key|将 key 中储存的数字值减一。|
|19|	DECRBY key decrementkey |所储存的值减去给定的减量值（decrement） 。|
|20|	APPEND key value|如果 key 已经存在并且是一个字符串， APPEND 命令将指定的 value 追加到该 key 原来值（value）的末尾。|

如下

```
127.0.0.1:6379> GETRANGE newname 0 4
"lumnc"
127.0.0.1:6379> GETSET newname 'Kally'
"lumnca"
127.0.0.1:6379> GETBIT newname 4
(integer) 1
127.0.0.1:6379> APPEND newname 'Lumnca'
(integer) 11
127.0.0.1:6379> GET newname
"KallyLumnca"
127.0.0.1:6379> 
```

